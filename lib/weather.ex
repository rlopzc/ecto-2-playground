defmodule E2P.Weather do
  use Ecto.Schema
  alias E2P.Repo
  alias E2P.Weather
  import Ecto.Query
  import Ecto.Changeset

  schema "weather" do
    field :city     # Defaults to type :string
    field :temp_lo, :integer
    field :temp_hi, :integer
    field :prcp,    :float, default: 0.0

    timestamps
  end

  def changeset(struct, params \\ %{}) do
    struct
    |> cast(params, [:city, :temp_lo, :temp_hi, :prcp])
    |> validate_required([:city])
    |> validate_number(:temp_lo, less_than: 50)
    |> validate_number(:temp_hi, less_than: 50)
    |> validate_number(:prcp, greather_than_or_equal_to: 0)
  end


  ##################
  # Schema Queries #
  ##################

  def all do
    Repo.all(Weather)
  end

  # Can't insert if changeset is invalid
  # Enforcing that param weather must be an Ecto.Changeset
  def insert(%Ecto.Changeset{} = weather) do
    Repo.insert(weather)
  end

  @doc """
  It returns a tuple containing the number of entries and any returned result
  as second element. If the database does not support RETURNING in UPDATE
  statements or no return result was selected, the second element will be nil.

  When a schema is given, the values given will be properly dumped before being
  sent to the database. If the schema contains an autogenerated ID field, it
  will be handled either at the adapter or the storage layer. However any other
  autogenerated value, like timestamps, won’t be autogenerated when using
  insert_all/3. This is by design as this function aims to be a more direct
  way to insert data into the database without the conveniences of insert/2.

  This is also consistent with update_all/3 that does not handle
  timestamps as well.
  """
  def insert_all do
    {records_inserted, ids} =
      Repo.insert_all(Weather,
                      [
                        [city: "Mexico", temp_lo: 10, temp_hi: 25, inserted_at: Ecto.DateTime.utc, updated_at: Ecto.DateTime.utc],
                        [city: "Mérida", temp_lo: 18, temp_hi: 34, inserted_at: Ecto.DateTime.utc, updated_at: Ecto.DateTime.utc]
                      ],
                      returning: [:id])
    IO.puts "Records inserted: #{records_inserted}"
    IO.inspect Enum.map(ids, fn(%{id: id}) -> id end), char_lists: :as_lists
    :ok
  end

  def update_all do
    {records_updated, _returned_values} = Repo.update_all(Weather, set: [temp_lo: 5])
    IO.puts "Records updated: #{records_updated}"
    :ok
  end

  def delete_all do
    {records_deleted, ids} = Repo.delete_all(Weather, returning: [:id])
    IO.puts "Records deleted: #{records_deleted}"
    IO.inspect Enum.map(ids, fn(%{id: id}) -> id end), char_lists: :as_lists
    :ok
  end

  ######################
  # Schemaless Queries #
  ######################

  def select_cities do
    # query = from "weather", select: [:city]
    query = from w in "weather", select: w.city
    Repo.all(query)
  end

  def select_cities_w_tmp_hi_than(temp) do
    query =
      from w in "weather",
      where: w.temp_hi >= ^temp,
      select: [:city]
    Repo.all(query)
  end
end
